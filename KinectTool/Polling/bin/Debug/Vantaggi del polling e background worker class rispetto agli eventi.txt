Before demonstrating how to code the polling model, it is good to understand the circumstances under which an application would require polling. The most basic reason for using polling is performance. Polling removes the innate overhead associated with events. When an application takes on frame retrieval, it is rewarded with performance gains. The drawback is polling is more complicated to implement than using events.
Overall, the polling model should perform better than the event model,although, due to the simplicity of these examples, any change in performance may be marginal at best.
The code to get the frame and update the WriteableBitmap is wrapped in a try-catch statement, because of the possibilities of the OpenNextFrame method call throwing an exception. The 100 milliseconds timeout duration passed to the OpenNextFrame call is fairly arbitrary. A well-chosen timeout ensures the application continues to operate smoothly even if a frame or two are skipped. You will also want your application to maintain as close to 30 frames per second as possible.
This example of using polling, however, continues to suffer from another problem. By using the CompositionTarget object, the application remains tied to WPF’s UI thread. Any long-running data processing or poorly chosen timeout for the OpenNextFrame method can cause slow, choppy, or unresponsive behavior in the application, because it executes on the UI thread. The solution is to fork a new thread and implement all polling and data processing on the secondary thread.
For the contrast between polling using the CompositionTarget and a background thread, create a new WPF project in Visual Studio. In .NET, working with threads is made easy with the BackgroundWorker class. Using a BackgroundWorker object developers do not have to concern themselves with the tedious work of managing the thread. Starting and stopping the thread becomes trivial. Developers are only responsible for writing the code that executes on the thread. To use the BackgroundWorker class, add a reference to System.ComponentModel to the set of using statements in MainWindow.xaml.cs. When finished, add the code from Listing 2-13.

The polling of data with background workerclass occurs on a background thread, but we want to update UI elements, which exist on another thread. This is the joy of working across threads. To update the UI elements from the background thread, we use the Dispatcher object. Each UI element in WPF has a Dispatcher, which is used to execute units of work on the same thread as the UI element. Listing 2-14 contains the updated versions of the DiscoverKinectSensor and PollColorImageStream methods. The changes necessary to update the UI thread are shown in bold.
Polling has distinct advantages over the event model, but at the cost of additional work for the developer and potential complexity to the application code. In most applications, the event model is adequate and should be used instead of polling; the primary exception for not using the event model is when your application is not written for WPF. For example, any console, XNA, or other application using a custom application loop should employ the polling architecture model. It is recommended that all WPF-based applications initially use the frame-ready events on the KinectSensor and only transition to polling if performance concerns warrant polling.
BeginInvoke, underneath, does the same thing has Invoke. The difference is that the calling code doesn't wait for the dispatcher to actually complete thework.

For this project, we use the MapDepthToColorImagePoint method to translate a depth image pixel position into a pixel position on a color image. In case you are wondering, there is not a method to get the depth pixel based on the coordinates of a color pixel.
The next two lines code in bold, which enable the color and depth stream, factor into the quality of our background subtraction process. When mapping between the color and depth images,it is best that the color image resolution be twice that of the depth stream, to ensure the best possible pixel translation.(pag78)